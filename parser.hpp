/*
    Boson v1.0 - Grammar analyzer generator

        Author: ict
        Email:  ictxiangxin@hotmail.com
        Site:   https://github.com/ictxiangxin/boson

    This code was generated by boson python code generator.
        
         0: !name_0 -> !name_0 statement
         1: !name_0 -> ~
         2: !name_1 -> t_comma expression
         3: !name_2 -> !name_2 !name_1
         4: !name_2 -> ~
         5: !name_3 -> t_minus
         6: !name_3 -> t_plus
         7: !name_4 -> !name_3
         8: !name_5 -> t_divide
         9: !name_5 -> t_times
        10: !name_6 -> !name_5
        11: arguments -> expression !name_2
        12: calculator -> !name_0
        13: expression -> expression !name_4 expression_high
        14: expression -> expression_high
        15: expression_final -> function
        16: expression_final -> t_number
        17: expression_final -> t_parenthesis_l expression t_parenthesis_r
        18: expression_final -> t_symbol
        19: expression_high -> expression_high !name_6 expression_top
        20: expression_high -> expression_top
        21: expression_top -> expression_final
        22: expression_top -> expression_top t_power expression_final
        23: function -> t_symbol t_parenthesis_l arguments t_parenthesis_r
        24: statement -> function
        25: statement -> t_symbol t_assign expression
*/


#include <stack>
#include <vector>
#include <set>
#include <unordered_map>
#include <string>
#include <functional>


class Token {
public:
    Token() = default;

    Token(std::string &text, const int line, std::string &symbol): text(text), line(line), symbol(symbol) {};

    Token(const char *text, const int line, const char *symbol): text(text), line(line), symbol(symbol) {};

    Token(const char *text, const int line, std::string &symbol): text(text), line(line), symbol(symbol) {};

    Token(std::string &text, const int line, const char *symbol): text(text), line(line), symbol(symbol) {};

    std::string text;
    int line = -1;
    std::string symbol;
};


class BosonGrammarNode {
public:
    BosonGrammarNode() = default;

    explicit BosonGrammarNode(std::string &text) {
        this->set_text(text);
    }

    int get_reduce_number() {
        return this->_reduce_number;
    }

    void set_reduce_number(int reduce_number) {
        this->_reduce_number = reduce_number;
    }

    std::string &get_text() {
        return this->_text;
    }

    void set_text(std::string &text) {
        this->_text = text;
    }

    void append(const BosonGrammarNode &item) {
        this->_children.push_back(item);
    }

    void insert(int index, const BosonGrammarNode &item) {
        this->_children.insert(this->_children.begin() + index, item);
    }

    std::vector<BosonGrammarNode> &children() {
        return this->_children;
    }

    BosonGrammarNode &operator[](int index) {
        return this->_children[index];
    }

private:
    int _reduce_number = -1;
    std::string _text;
    std::vector<BosonGrammarNode> _children;
};


class BosonGrammar {
public:
    BosonGrammar() = default;

    BosonGrammarNode &get_grammar_tree() {
        return this->_grammar_tree;
    }

    void set_grammar_tree(BosonGrammarNode &grammar_tree) {
        this->_grammar_tree = grammar_tree;
    }

    int get_error_index() {
        return this->_error_index;
    }

    void set_error_index(int error_index) {
        this->_error_index = error_index;
    }

private:
    BosonGrammarNode _grammar_tree;
    int _error_index = -1;
};


template <class T>
class BosonSemanticsNode {
public:
    BosonSemanticsNode() = default;

    explicit BosonSemanticsNode(T data): _data(data) {};

    static BosonSemanticsNode &null_node() {
        static BosonSemanticsNode node;
        return node;
    }

    T &get_data() {
        return this->_data;
    }

    void set_data(T data) {
        this->_data = std::move(data);
    }

    int get_reduce_number() {
        return this->_reduce_number;
    }

    void set_reduce_number(int reduce_number) {
        this->_reduce_number = reduce_number;
    }

    const std::string &get_text() {
        return this->_text;
    }

    void set_text(std::string &text) {
        this->_text = text;
    }

    void append(const BosonSemanticsNode &item) {
        this->_children.push_back(item);
    }

    void insert(int index, const BosonSemanticsNode &item) {
        this->_children.insert(this->_children.begin() + index, item);
    }

    std::vector<BosonSemanticsNode> &children() {
        return this->_children;
    }

    BosonSemanticsNode &operator[](int index) {
        return this->_children[index];
    }

protected:
    int _reduce_number = -1;
    std::string _text;
    std::vector<BosonSemanticsNode> _children;
    T _data;
};


class BosonGrammarAnalyzer {
public:
    BosonGrammarAnalyzer() = default;

    BosonGrammar grammar_analysis(std::vector<Token> token_list) {
        BosonGrammar grammar;
        std::stack<int> analysis_stack;
        std::stack<BosonGrammarNode> symbol_stack;
        analysis_stack.push(0);
        int token_index = 0;
        while (token_index < token_list.size()) {
            Token &token = token_list[token_index];
            int current_state = analysis_stack.top();
            std::string operation = "e";
            int terminal_index = this->_terminal_index[token.symbol];
            if (this->_action_table.count(current_state)) {
                std::unordered_map<int, std::string> &actions = this->_action_table[current_state];
                if (actions.count(terminal_index)) {
                    operation = actions[terminal_index];
                }
            }
            char operation_flag = operation[0];
            if (operation_flag == 'e') {
                grammar.set_error_index(token_index);
                return grammar;
            } else if (operation_flag == 's') {
                int state_number = (int) strtol(operation.c_str() + 1, nullptr, 10);
                analysis_stack.push(state_number);
                token_index++;
                BosonGrammarNode grammar_node(token.text);
                symbol_stack.push(grammar_node);
            } else if (operation_flag == 'r') {
                int statement_index = (int) strtol(operation.c_str() + 1, nullptr, 10) - 1;
                int reduce_sum = this->_reduce_symbol_sum[statement_index];
                for (int i = 0; i < reduce_sum; i++) {
                    analysis_stack.pop();
                }
                current_state = analysis_stack.top();
                int current_non_terminal_index = this->_reduce_to_non_terminal_index[statement_index];
                int goto_next_state = -1;
                if (this->_goto_table.count(current_state)) {
                    std::unordered_map<int, int> &goto_table = this->_goto_table[current_state];
                    if (goto_table.count(current_non_terminal_index)) {
                        goto_next_state = goto_table[current_non_terminal_index];
                    }
                }
                if (goto_next_state == -1) {
                    throw std::runtime_error("Invalid goto action.");
                }
                analysis_stack.push(goto_next_state);
                if (this->_node_table.count(statement_index)) {
                    std::vector<BosonGrammarNode> symbol_package;
                    for (int i = 0; i < reduce_sum; i++) {
                        symbol_package.insert(symbol_package.begin(), symbol_stack.top());
                        symbol_stack.pop();
                    }
                    symbol_stack.push(this->_generate_grammar_tuple(statement_index, this->_node_table[statement_index], symbol_package));
                } else if (this->_none_grammar_tuple_reduce.count(statement_index)) {
                    BosonGrammarNode grammar_node;
                    for (int i = 0; i < reduce_sum; i++) {
                        grammar_node.insert(0, symbol_stack.top());
                        symbol_stack.pop();
                    }
                    grammar_node.set_reduce_number(statement_index);
                    symbol_stack.push(grammar_node);
                } else {
                    throw std::runtime_error("Invalid reduce number.");
                }
            } else if (operation_flag == 'a') {
                grammar.set_grammar_tree(symbol_stack.top());
                return grammar;
            } else {
                throw std::runtime_error("Invalid action.");
            }
        }
        throw std::runtime_error("Analyzer unusual exit.");
    }

private:
    std::unordered_map<std::string, int>_terminal_index = {
        {"$", 0},
        {"t_times", 1},
        {"t_power", 2},
        {"t_parenthesis_l", 3},
        {"t_parenthesis_r", 4},
        {"t_assign", 5},
        {"t_comma", 6},
        {"t_symbol", 7},
        {"t_minus", 8},
        {"t_number", 9},
        {"t_plus", 10},
        {"t_divide", 11}
    };
    
    std::unordered_map<int, std::unordered_map<int, std::string>> _action_table = {
        {0, {{0, "r2"}, {7, "r2"}}}, 
        {1, {{0, "r13"}, {7, "s5"}}}, 
        {2, {{0, "a"}}}, 
        {3, {{0, "r1"}, {7, "r1"}}}, 
        {4, {{0, "r25"}, {7, "r25"}}}, 
        {5, {{3, "s7"}, {5, "s6"}}}, 
        {6, {{3, "s13"}, {7, "s11"}, {9, "s8"}}}, 
        {7, {{3, "s13"}, {7, "s11"}, {9, "s8"}}}, 
        {8, {{0, "r17"}, {1, "r17"}, {2, "r17"}, {4, "r17"}, {6, "r17"}, {7, "r17"}, {8, "r17"}, {10, "r17"}, {11, "r17"}}}, 
        {9, {{0, "r15"}, {1, "s20"}, {4, "r15"}, {6, "r15"}, {7, "r15"}, {8, "r15"}, {10, "r15"}, {11, "s19"}}}, 
        {10, {{0, "r21"}, {1, "r21"}, {2, "s22"}, {4, "r21"}, {6, "r21"}, {7, "r21"}, {8, "r21"}, {10, "r21"}, {11, "r21"}}}, 
        {11, {{0, "r19"}, {1, "r19"}, {2, "r19"}, {3, "s7"}, {4, "r19"}, {6, "r19"}, {7, "r19"}, {8, "r19"}, {10, "r19"}, {11, "r19"}}}, 
        {12, {{0, "r22"}, {1, "r22"}, {2, "r22"}, {4, "r22"}, {6, "r22"}, {7, "r22"}, {8, "r22"}, {10, "r22"}, {11, "r22"}}}, 
        {13, {{3, "s13"}, {7, "s11"}, {9, "s8"}}}, 
        {14, {{0, "r16"}, {1, "r16"}, {2, "r16"}, {4, "r16"}, {6, "r16"}, {7, "r16"}, {8, "r16"}, {10, "r16"}, {11, "r16"}}}, 
        {15, {{0, "r26"}, {7, "r26"}, {8, "s27"}, {10, "s25"}}}, 
        {16, {{4, "s28"}}}, 
        {17, {{4, "r5"}, {6, "r5"}, {8, "s27"}, {10, "s25"}}}, 
        {18, {{3, "r11"}, {7, "r11"}, {9, "r11"}}}, 
        {19, {{3, "r9"}, {7, "r9"}, {9, "r9"}}}, 
        {20, {{3, "r10"}, {7, "r10"}, {9, "r10"}}}, 
        {21, {{3, "s13"}, {7, "s11"}, {9, "s8"}}}, 
        {22, {{3, "s13"}, {7, "s11"}, {9, "s8"}}}, 
        {23, {{4, "s32"}, {8, "s27"}, {10, "s25"}}}, 
        {24, {{3, "r8"}, {7, "r8"}, {9, "r8"}}}, 
        {25, {{3, "r7"}, {7, "r7"}, {9, "r7"}}}, 
        {26, {{3, "s13"}, {7, "s11"}, {9, "s8"}}}, 
        {27, {{3, "r6"}, {7, "r6"}, {9, "r6"}}}, 
        {28, {{0, "r24"}, {1, "r24"}, {2, "r24"}, {4, "r24"}, {6, "r24"}, {7, "r24"}, {8, "r24"}, {10, "r24"}, {11, "r24"}}}, 
        {29, {{4, "r12"}, {6, "s34"}}}, 
        {30, {{0, "r20"}, {1, "r20"}, {2, "s22"}, {4, "r20"}, {6, "r20"}, {7, "r20"}, {8, "r20"}, {10, "r20"}, {11, "r20"}}}, 
        {31, {{0, "r23"}, {1, "r23"}, {2, "r23"}, {4, "r23"}, {6, "r23"}, {7, "r23"}, {8, "r23"}, {10, "r23"}, {11, "r23"}}}, 
        {32, {{0, "r18"}, {1, "r18"}, {2, "r18"}, {4, "r18"}, {6, "r18"}, {7, "r18"}, {8, "r18"}, {10, "r18"}, {11, "r18"}}}, 
        {33, {{0, "r14"}, {1, "s20"}, {4, "r14"}, {6, "r14"}, {7, "r14"}, {8, "r14"}, {10, "r14"}, {11, "s19"}}}, 
        {34, {{3, "s13"}, {7, "s11"}, {9, "s8"}}}, 
        {35, {{4, "r4"}, {6, "r4"}}}, 
        {36, {{4, "r3"}, {6, "r3"}, {8, "s27"}, {10, "s25"}}}
    };

    std::unordered_map<int, std::unordered_map<int, int>> _goto_table = {
        {0, {{8, 2}, {14, 1}}}, 
        {1, {{0, 4}, {10, 3}}}, 
        {6, {{0, 14}, {5, 9}, {6, 15}, {7, 12}, {9, 10}}}, 
        {7, {{0, 14}, {5, 9}, {6, 17}, {7, 12}, {9, 10}, {12, 16}}}, 
        {9, {{3, 21}, {11, 18}}}, 
        {13, {{0, 14}, {5, 9}, {6, 23}, {7, 12}, {9, 10}}}, 
        {15, {{1, 24}, {15, 26}}}, 
        {17, {{1, 24}, {2, 29}, {15, 26}}}, 
        {21, {{0, 14}, {7, 12}, {9, 30}}}, 
        {22, {{0, 14}, {7, 31}}}, 
        {23, {{1, 24}, {15, 26}}}, 
        {26, {{0, 14}, {5, 33}, {7, 12}, {9, 10}}}, 
        {29, {{4, 35}}}, 
        {33, {{3, 21}, {11, 18}}}, 
        {34, {{0, 14}, {5, 9}, {6, 36}, {7, 12}, {9, 10}}}, 
        {36, {{1, 24}, {15, 26}}}
    };
    
    std::unordered_map<int, std::string> _node_table = {
        {0, "('*0', '1')"},
        {1, "()"},
        {25, "('0', '2')"},
        {23, "('0', '2')"},
        {3, "('*0', '1')"},
        {4, "()"},
        {11, "('0', ('*1', ('1',)))"},
        {13, "('0', '*1', '2')"},
        {19, "('0', '*1', '2')"},
        {22, "('0', '1', '2')"},
        {17, "('1',)"},
        {18, "('0',)"},
        {16, "('0',)"}
    };

    std::vector<int> _reduce_symbol_sum = {2, 0, 2, 2, 0, 1, 1, 1, 1, 1, 1, 2, 1, 3, 1, 1, 1, 3, 1, 3, 1, 1, 3, 4, 1, 3};

    std::vector<int> _reduce_to_non_terminal_index = {14, 14, 4, 2, 2, 1, 1, 15, 11, 11, 3, 12, 8, 6, 6, 7, 7, 7, 7, 5, 5, 9, 9, 0, 10, 10};

    std::set<int> _none_grammar_tuple_reduce = {2, 5, 6, 7, 8, 9, 10, 12, 14, 15, 20, 21, 24};

    BosonGrammarNode _generate_grammar_tuple(int statement_index, std::string &node_tuple, std::vector<BosonGrammarNode> &symbol_package) {
        BosonGrammarNode grammar_node;
        int state = 0;
        int sub_start_index = -1;
        bool star = false;
        int parenthesis_count = 0;
        std::string number_text;
        for (size_t i = 1; i < node_tuple.length(); i++) {
            char c = node_tuple[i];
            if (state == 0) {
                if (c == '(') {
                    state = 2;
                } else if (c == '$') {
                    BosonGrammarNode reduce_node;
                    reduce_node.set_reduce_number(statement_index);
                    grammar_node.append(reduce_node);
                } else if (c == '?') {
                    for (auto &node : symbol_package) {
                        grammar_node.append(node);
                    }
                } else if (c == '\'' || c == ',' || c == ' ' || c == ')') {
                    continue;
                } else if (c == '*') {
                    star = true;
                } else if ('0' <= c && c <= '9') {
                    number_text += c;
                    state = 1;
                } else {
                    throw std::runtime_error("Invalid grammar node.");
                }
            } else if (state == 1) {
                if ('0' <= c && c <= '9') {
                    number_text += c;
                } else {
                    i--;
                    int reduce_number = (int) strtol(number_text.c_str(), nullptr, 10);
                    if (star) {
                        for (auto &node : symbol_package[reduce_number].children()) {
                            grammar_node.append(node);
                        }
                    } else {
                        grammar_node.append(symbol_package[reduce_number]);
                    }
                    star = false;
                    number_text = "";
                    state = 0;
                }
            } else if (state == 2) {
                if (c == '*') {
                    star = true;
                } else if (c == '\'' || c == ',' || c == ' ') {
                    continue;
                } else if ('0' <= c && c <= '9') {
                    number_text += c;
                } else {
                    i--;
                    state = 3;
                }
            } else {
                if (c == '(') {
                    if (parenthesis_count == 0) {
                        sub_start_index = i;
                    }
                    parenthesis_count++;
                } else if (c == ')') {
                    parenthesis_count--;
                    if (parenthesis_count == 0) {
                        int reduce_number = (int) strtol(number_text.c_str(), nullptr, 10);
                        std::string sub_node_tuple = node_tuple.substr(sub_start_index, i - sub_start_index + 1);
                        for (auto &each: symbol_package[reduce_number].children()) {
                            BosonGrammarNode sub_node = this->_generate_grammar_tuple(-1, sub_node_tuple, each.children());
                            if (star) {
                                for (auto &node : sub_node.children()) {
                                    grammar_node.append(node);
                                }
                            } else {
                                grammar_node.append(sub_node);
                            }
                        }
                        star = false;
                        number_text = "";
                        state = 0;
                    }
                }
            }
        }
        grammar_node.set_reduce_number(statement_index);
        return grammar_node;
    }
};


template <class T>
class BosonSemanticsAnalyzer {
public:
    using semantic_function = std::function<BosonSemanticsNode<T>(BosonSemanticsNode<T> &)>;

    BosonSemanticsAnalyzer() = default;

    BosonSemanticsNode<T> semantics_analysis(BosonGrammarNode &grammar_tree) {
        return this->_semantics_analysis(grammar_tree);
    }

    static BosonSemanticsNode<T> default_semantics_entity(BosonSemanticsNode<T> &semantics_node) {
        return semantics_node;
    }

    static BosonSemanticsNode<T> naive_semantics_entity(BosonSemanticsNode<T> &semantics_node) {
        if (semantics_node.children().size() == 1) {
            return semantics_node[0];
        } else {
            return semantics_node;
        }
    }

    void semantics_entity(int reduce_number, semantic_function function) {
        std::string reduce_name = "!grammar_" + std::to_string(reduce_number);
        this->semantics_entity(reduce_name, function);
    }

    void semantics_entity(const char *reduce_name, semantic_function function) {
        std::string reduce_name_string(reduce_name);
        this->semantics_entity(reduce_name_string, function);
    }

    void semantics_entity(std::string &reduce_name, semantic_function function) {
        this->_semantics_entity[reduce_name] = function;
    }

private:
    std::unordered_map<int, std::string> _reduce_number_to_grammar_name = {
        {25, "set_variable"}, 
        {23, "function"}, 
        {13, "compute"}, 
        {19, "compute"}, 
        {22, "compute"}, 
        {17, "expression"}, 
        {18, "get_variable"}, 
        {16, "number"}
    };

    std::unordered_map<int, int> _reduce_number_to_grammar_number = {
        {12, 0}, 
        {24, 2}, 
        {11, 4}, 
        {14, 6}, 
        {20, 8}, 
        {21, 10}, 
        {15, 12}
    };

    std::set<int> _naive_reduce_number = {5, 6, 8, 9, 14, 15, 16, 18, 20, 21, 24};

    std::unordered_map<std::string, semantic_function> _semantics_entity;

    BosonSemanticsNode<T> _semantics_analysis(BosonGrammarNode &grammar_tree) {
        std::string grammar_name;
        if (this->_reduce_number_to_grammar_name.count(grammar_tree.get_reduce_number())) {
            grammar_name = this->_reduce_number_to_grammar_name[grammar_tree.get_reduce_number()];
        } else if (this->_reduce_number_to_grammar_number.count(grammar_tree.get_reduce_number())) {
            grammar_name = "!grammar_" + std::to_string(this->_reduce_number_to_grammar_number[grammar_tree.get_reduce_number()]);
        } else {
            grammar_name = "!grammar_hidden";
        }
        BosonSemanticsNode<T> semantics_node;
        for (auto &node: grammar_tree.children()) {
            if (!node.children().empty()) {
                semantics_node.append(this->_semantics_analysis(node));
            } else {
                BosonSemanticsNode<T> temp_node;
                temp_node.set_reduce_number(node.get_reduce_number());
                temp_node.set_text(node.get_text());
                semantics_node.append(temp_node);
            }
        }
        if (this->_semantics_entity.count(grammar_name)) {
            return this->_semantics_entity[grammar_name](semantics_node);
        } else if (this->_naive_reduce_number.count(grammar_tree.get_reduce_number())) {
            return BosonSemanticsAnalyzer::naive_semantics_entity(semantics_node);
        } else {
            return BosonSemanticsAnalyzer::default_semantics_entity(semantics_node);
        }
    }
};
