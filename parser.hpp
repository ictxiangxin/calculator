/*
    Boson v1.3 - Grammar analyzer generator

        Author: ict
        Email:  ictxiangxin@hotmail.com
        Site:   https://github.com/ictxiangxin/boson

    These codes ware generated by the boson C++ code generator.
*/


#include <stack>
#include <vector>
#include <set>
#include <unordered_map>
#include <string>
#include <functional>


class Token {
public:
    Token() = default;

    Token(std::string &text, const int line, std::string &symbol): text(text), line(line), symbol(symbol) {};

    Token(const char *text, const int line, const char *symbol): text(text), line(line), symbol(symbol) {};

    Token(const char *text, const int line, std::string &symbol): text(text), line(line), symbol(symbol) {};

    Token(std::string &text, const int line, const char *symbol): text(text), line(line), symbol(symbol) {};

    std::string text{};
    int line = -1;
    std::string symbol{};
};


class Tokenizer {
public:
    using lexical_function = std::function<std::string &(std::string &)>;

    Tokenizer() = default;

    std::vector<Token> &token_list() {
        return this->_token_list;
    }

    void skip() {
        this->_skip = true;
    }

    void newline() {
        this->_line++;
    }

    int error_line() {
        return _error_line;
    }

    int no_error_line() {
        return _no_error_line;
    }

    int tokenize(std::string text) {
        this->_token_list.clear();
        this->_line = 1;
        int state = this->_start_state;
        std::string token_string{};
        unsigned long index = 0;
        while (index < text.length()) {
            char character = text[index];
            index++;
            bool get_token = false;
            if (this->_non_greedy_state_set.count(state)) {
                get_token = true;
            }
            if (this->_move_table_attribute.count(state)) {
                std::vector<int> &attribute_list = this->_move_table_attribute[state];
                std::vector<std::set<char>> &character_set_list = this->_move_table_character_set[state];
                std::vector<std::vector<std::vector<int>>> &state_range_list = this->_move_table_range_list[state];
                std::vector<int> &next_state_list = this->_move_table_next_state[state];
                unsigned long i;
                for (i = 0; i < attribute_list.size(); i++) {
                    int attribute = attribute_list[i];
                    std::set<char> &character_set = character_set_list[i];
                    std::vector<std::vector<int>> &range_list = state_range_list[i];
                    int next_state = next_state_list[i];
                    bool condition;
                    if (attribute == 2) {
                        condition = !character_set.count(character);
                        for (auto & range : range_list) {
                            condition &= character < range[0] || character > range[1];
                        }
                    } else {
                        condition = character_set.count(character);
                        if (attribute == 1 && this->_character_set.count(character) == 0) {
                            condition = true;
                        }
                        for (auto & range : range_list) {
                            if (condition || (range[0] <= character && character <= range[1])) {
                                condition = true;
                                break;
                            }
                        }
                    }
                    if (condition) {
                        token_string += character;
                        state = next_state;
                        break;
                    }
                }
                if (i == attribute_list.size()) {
                    if (this->_end_state_set.count(state)) {
                        get_token = true;
                    } else {
                        this->_error_line = this->_line;
                        return this->_error_line;
                    }
                }
            } else {
                if (this->_end_state_set.count(state)) {
                    get_token = true;
                } else {
                    this->_error_line = this->_line;
                    return this->_error_line;
                }
            }
            if (get_token) {
                this->_generate_token(state, token_string);
                token_string = "";
                state = this->_start_state;
                index--;
            }
        }
        if (this->_end_state_set.count(state)) {
            this->_generate_token(state, token_string);
        } else {
            throw std::runtime_error("Invalid state.");
        }
        this->_token_list.emplace_back("", this->_line, "$");
        return this->_error_line;
    }

    void lexical_function_entity(std::string &function_name, lexical_function &function) {
        this->_lexical_function[function_name] = function;
    }

private:
    std::vector<Token> _token_list{};
    int _line = 1;
    int _error_line = -1;
    int _no_error_line = -1;
    bool _skip = false;
    std::unordered_map<int, std::vector<int>> _move_table_attribute = {
        {0, {0,0,0,0,0,0,0,0,0,0,0,0,0}},
        {14, {0}},
        {4, {0}},
        {3, {0}},
        {2, {0,0}},
        {1, {0}}
    };
    std::unordered_map<int, std::vector<std::set<char>>> _move_table_character_set = {
        {0, {{'\x5f'},{},{'\x09','\x20'},{'\x0a'},{'\x3d'},{'\x28'},{'\x29'},{'\x2c'},{'\x2b'},{'\x2d'},{'\x2a'},{'\x2f'},{'\x5e'}}},
        {14, {{}}},
        {4, {{'\x0d'}}},
        {3, {{'\x09','\x20'}}},
        {2, {{},{'\x2e'}}},
        {1, {{'\x5f'}}}
    };
    std::unordered_map<int, std::vector<std::vector<std::vector<int>>>> _move_table_range_list = {
        {0, {{{'\x41', '\x5a'},{'\x61', '\x7a'}},{{'\x30', '\x39'}},{},{},{},{},{},{},{},{},{},{},{}}},
        {14, {{{'\x30', '\x39'}}}},
        {4, {{}}},
        {3, {{}}},
        {2, {{{'\x30', '\x39'}},{}}},
        {1, {{{'\x30', '\x39'},{'\x41', '\x5a'},{'\x61', '\x7a'}}}}
    };
    std::unordered_map<int, std::vector<int>> _move_table_next_state = {
        {0, {1,2,3,4,5,6,7,8,9,10,11,12,13}},
        {14, {14}},
        {4, {15}},
        {3, {3}},
        {2, {2,14}},
        {1, {1}}
    };
    std::set<char> _character_set = {'\x50','\x65','\x45','\x70','\x61','\x42','\x46','\x5f','\x28','\x2a','\x2b','\x52','\x6b','\x73','\x38','\x3d','\x59','\x6c','\x72','\x4c','\x66','\x75','\x35','\x4b','\x76','\x31','\x6a','\x2f','\x6e','\x4d','\x41','\x2e','\x36','\x49','\x7a','\x79','\x34','\x30','\x33','\x53','\x71','\x4a','\x63','\x56','\x78','\x6f','\x47','\x43','\x6d','\x74','\x57','\x09','\x67','\x44','\x4f','\x37','\x68','\x2c','\x2d','\x5a','\x4e','\x0d','\x51','\x29','\x39','\x20','\x32','\x69','\x55','\x64','\x0a','\x5e','\x48','\x62','\x58','\x54','\x77'};
    int _start_state = 0;
    std::set<int> _end_state_set = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
    std::unordered_map<int, std::string> _lexical_symbol_mapping = {
        {1, "t_symbol"},
        {2, "t_number"},
        {3, "skip"},
        {4, "newline"},
        {5, "!symbol_1"},
        {6, "!symbol_2"},
        {7, "!symbol_3"},
        {8, "!symbol_4"},
        {9, "!symbol_5"},
        {10, "!symbol_6"},
        {11, "!symbol_7"},
        {12, "!symbol_8"},
        {13, "!symbol_9"},
        {14, "t_number"},
        {15, "newline"}
    };
    std::set<int> _non_greedy_state_set = {};
    std::unordered_map<std::string, std::vector<std::string>> _symbol_function_mapping = {
        {"t_symbol", {}},
        {"t_number", {}},
        {"skip", {"skip"}},
        {"newline", {"skip","newline"}}
    };
    std::unordered_map<std::string, lexical_function> _lexical_function{};

    std::string &_invoke_lexical_function(std::string &symbol, std::string &token_string) {
        this->_skip = false;
        if (this->_symbol_function_mapping.count(symbol)) {
            for (const auto& function : this->_symbol_function_mapping[symbol]) {
                if (this->_lexical_function.count(function)) {
                    token_string = this->_lexical_function[function](token_string);
                } else if (function == "skip") {
                    this->skip();
                } else if (function == "newline") {
                    this->newline();
                }
            }
        }
        return token_string;
    }

    void _generate_token(int state, std::string &token_string) {
        std::string symbol;
        if (this->_lexical_symbol_mapping.count(state)) {
            symbol = this->_lexical_symbol_mapping[state];
        } else {
            symbol = "!symbol";
        }
        token_string = this->_invoke_lexical_function(symbol, token_string);
        if (!this->_skip) {
            this->_token_list.emplace_back(token_string, this->_line, symbol);
        }
    }
};


class BosonGrammarNode {
public:
    BosonGrammarNode() = default;

    explicit BosonGrammarNode(std::string &text) {
        this->set_text(text);
    }

    int get_reduce_number() {
        return this->_reduce_number;
    }

    void set_reduce_number(int reduce_number) {
        this->_reduce_number = reduce_number;
    }

    std::string &get_text() {
        return this->_text;
    }

    void set_text(std::string &text) {
        this->_text = text;
    }

    void append(const BosonGrammarNode &item) {
        this->_children.push_back(item);
    }

    void insert(int index, const BosonGrammarNode &item) {
        this->_children.insert(this->_children.begin() + index, item);
    }

    std::vector<BosonGrammarNode> &children() {
        return this->_children;
    }

    BosonGrammarNode &operator[](int index) {
        return this->_children[index];
    }

private:
    int _reduce_number = -1;
    std::string _text{};
    std::vector<BosonGrammarNode> _children{};
};


class BosonGrammar {
public:
    BosonGrammar() = default;

    BosonGrammarNode &get_grammar_tree() {
        return this->_grammar_tree;
    }

    void set_grammar_tree(BosonGrammarNode &grammar_tree) {
        this->_grammar_tree = grammar_tree;
    }

    int get_error_index() {
        return this->_error_index;
    }

    void set_error_index(int error_index) {
        this->_error_index = error_index;
    }

    int no_error_index() {
        return this->_no_error_index;
    }

private:
    BosonGrammarNode _grammar_tree;
    int _error_index = -1;
    int _no_error_index = -1;
};


template <class T>
class BosonSemanticsNode {
public:
    BosonSemanticsNode() = default;

    explicit BosonSemanticsNode(T data): _data(data) {};

    static BosonSemanticsNode &null_node() {
        static BosonSemanticsNode node;
        return node;
    }

    T &get_data() {
        return this->_data;
    }

    void set_data(T data) {
        this->_data = std::move(data);
    }

    int get_reduce_number() {
        return this->_reduce_number;
    }

    void set_reduce_number(int reduce_number) {
        this->_reduce_number = reduce_number;
    }

    const std::string &get_text() {
        return this->_text;
    }

    void set_text(std::string &text) {
        this->_text = text;
    }

    void append(const BosonSemanticsNode &item) {
        this->_children.push_back(item);
    }

    void insert(int index, const BosonSemanticsNode &item) {
        this->_children.insert(this->_children.begin() + index, item);
    }

    std::vector<BosonSemanticsNode> &children() {
        return this->_children;
    }

    BosonSemanticsNode &operator[](int index) {
        return this->_children[index];
    }

protected:
    int _reduce_number = -1;
    std::string _text{};
    std::vector<BosonSemanticsNode> _children{};
    T _data;
};


class GrammarAnalyzer {
public:
    GrammarAnalyzer() = default;

    BosonGrammar grammar_analysis(std::vector<Token> token_list) {
        BosonGrammar grammar;
        std::stack<int> analysis_stack;
        std::stack<BosonGrammarNode> symbol_stack;
        analysis_stack.push(0);
        int token_index = 0;
        while (token_index < token_list.size()) {
            Token &token = token_list[token_index];
            int current_state = analysis_stack.top();
            std::string operation = "e";
            int terminal_index = this->_terminal_index_mapping[token.symbol];
            if (this->_sparse_action_table.count(current_state)) {
                std::unordered_map<int, std::string> &actions = this->_sparse_action_table[current_state];
                if (actions.count(terminal_index)) {
                    operation = actions[terminal_index];
                }
            }
            char operation_flag = operation[0];
            if (operation_flag == 'e') {
                grammar.set_error_index(token_index);
                return grammar;
            } else if (operation_flag == 's') {
                int state_number = (int) strtol(operation.c_str() + 1, nullptr, 10);
                analysis_stack.push(state_number);
                token_index++;
                BosonGrammarNode grammar_node(token.text);
                symbol_stack.push(grammar_node);
            } else if (operation_flag == 'r') {
                int statement_index = (int) strtol(operation.c_str() + 1, nullptr, 10);
                int reduce_count = this->_reduce_symbol_count[statement_index];
                for (int i = 0; i < reduce_count; i++) {
                    analysis_stack.pop();
                }
                current_state = analysis_stack.top();
                int current_non_terminal_index_mapping = this->_reduce_non_terminal_index[statement_index];
                int goto_next_state = -1;
                if (this->_sparse_goto_table.count(current_state)) {
                    std::unordered_map<int, int> &goto_table = this->_sparse_goto_table[current_state];
                    if (goto_table.count(current_non_terminal_index_mapping)) {
                        goto_next_state = goto_table[current_non_terminal_index_mapping];
                    }
                }
                if (goto_next_state == -1) {
                    throw std::runtime_error("Invalid goto action.");
                }
                analysis_stack.push(goto_next_state);
                if (this->_sentence_index_grammar_tuple_mapping.count(statement_index)) {
                    std::vector<BosonGrammarNode> symbol_package{};
                    for (int i = 0; i < reduce_count; i++) {
                        symbol_package.insert(symbol_package.begin(), symbol_stack.top());
                        symbol_stack.pop();
                    }
                    BosonGrammarNode grammar_node;
                    for (std::string &node_string : this->_sentence_index_grammar_tuple_mapping[statement_index]) {
                        if (node_string[0] == '*') {
                            int reduce_number = (int) strtol(node_string.c_str() + 1, nullptr, 10);
                            for (BosonGrammarNode &node : symbol_package[reduce_number].children()) {
                                grammar_node.append(node);
                            }
                        } else {
                            int reduce_number = (int) strtol(node_string.c_str(), nullptr, 10);
                            grammar_node.append(symbol_package[reduce_number]);
                        }
                    }
                    grammar_node.set_reduce_number(statement_index);
                    symbol_stack.push(grammar_node);
                } else if (this->_none_grammar_tuple_reduce_set.count(statement_index)) {
                    BosonGrammarNode grammar_node;
                    for (int i = 0; i < reduce_count; i++) {
                        grammar_node.insert(0, symbol_stack.top());
                        symbol_stack.pop();
                    }
                    grammar_node.set_reduce_number(statement_index);
                    symbol_stack.push(grammar_node);
                } else {
                    throw std::runtime_error("Invalid reduce number.");
                }
            } else if (operation_flag == 'a') {
                grammar.set_grammar_tree(symbol_stack.top());
                return grammar;
            } else {
                throw std::runtime_error("Invalid action.");
            }
        }
        throw std::runtime_error("Analyzer unusual exit.");
    }

private:
    std::unordered_map<std::string, int>_terminal_index_mapping = {
        {"!symbol_7", 0},
        {"!symbol_2", 1},
        {"!symbol_6", 2},
        {"!symbol_1", 3},
        {"!symbol_4", 4},
        {"!symbol_3", 5},
        {"$", 6},
        {"!symbol_5", 7},
        {"t_number", 8},
        {"!symbol_8", 9},
        {"t_symbol", 10},
        {"!symbol_9", 11}
    };
    
    std::unordered_map<int, std::unordered_map<int, std::string>> _sparse_action_table = {
        {0, {{6, "r19"}, {10, "r19"}}}, 
        {1, {{6, "a"}}}, 
        {2, {{6, "r1"}, {10, "s4"}}}, 
        {3, {{6, "r10"}, {10, "r10"}}}, 
        {4, {{1, "s6"}, {3, "s7"}}}, 
        {5, {{6, "r11"}, {10, "r11"}}}, 
        {6, {{1, "s13"}, {8, "s15"}, {10, "s10"}}}, 
        {7, {{1, "s13"}, {8, "s15"}, {10, "s10"}}}, 
        {8, {{2, "s28"}, {6, "r7"}, {7, "s27"}, {10, "r7"}}}, 
        {9, {{0, "s21"}, {2, "r8"}, {4, "r8"}, {5, "r8"}, {6, "r8"}, {7, "r8"}, {9, "s22"}, {10, "r8"}}}, 
        {10, {{0, "r2"}, {1, "s6"}, {2, "r2"}, {4, "r2"}, {5, "r2"}, {6, "r2"}, {7, "r2"}, {9, "r2"}, {10, "r2"}, {11, "r2"}}}, 
        {11, {{0, "r26"}, {2, "r26"}, {4, "r26"}, {5, "r26"}, {6, "r26"}, {7, "r26"}, {9, "r26"}, {10, "r26"}, {11, "s17"}}}, 
        {12, {{0, "r14"}, {2, "r14"}, {4, "r14"}, {5, "r14"}, {6, "r14"}, {7, "r14"}, {9, "r14"}, {10, "r14"}, {11, "r14"}}}, 
        {13, {{1, "s13"}, {8, "s15"}, {10, "s10"}}}, 
        {14, {{0, "r15"}, {2, "r15"}, {4, "r15"}, {5, "r15"}, {6, "r15"}, {7, "r15"}, {9, "r15"}, {10, "r15"}, {11, "r15"}}}, 
        {15, {{0, "r25"}, {2, "r25"}, {4, "r25"}, {5, "r25"}, {6, "r25"}, {7, "r25"}, {9, "r25"}, {10, "r25"}, {11, "r25"}}}, 
        {16, {{2, "s28"}, {5, "s25"}, {7, "s27"}}}, 
        {17, {{1, "s13"}, {8, "s15"}, {10, "s10"}}}, 
        {18, {{0, "r21"}, {2, "r21"}, {4, "r21"}, {5, "r21"}, {6, "r21"}, {7, "r21"}, {9, "r21"}, {10, "r21"}, {11, "r21"}}}, 
        {19, {{1, "s13"}, {8, "s15"}, {10, "s10"}}}, 
        {20, {{1, "r24"}, {8, "r24"}, {10, "r24"}}}, 
        {21, {{1, "r12"}, {8, "r12"}, {10, "r12"}}}, 
        {22, {{1, "r17"}, {8, "r17"}, {10, "r17"}}}, 
        {23, {{0, "r5"}, {2, "r5"}, {4, "r5"}, {5, "r5"}, {6, "r5"}, {7, "r5"}, {9, "r5"}, {10, "r5"}, {11, "s17"}}}, 
        {24, {{1, "s13"}, {8, "s15"}, {10, "s10"}}}, 
        {25, {{0, "r9"}, {2, "r9"}, {4, "r9"}, {5, "r9"}, {6, "r9"}, {7, "r9"}, {9, "r9"}, {10, "r9"}, {11, "r9"}}}, 
        {26, {{1, "r23"}, {8, "r23"}, {10, "r23"}}}, 
        {27, {{1, "r13"}, {8, "r13"}, {10, "r13"}}}, 
        {28, {{1, "r20"}, {8, "r20"}, {10, "r20"}}}, 
        {29, {{0, "s21"}, {2, "r22"}, {4, "r22"}, {5, "r22"}, {6, "r22"}, {7, "r22"}, {9, "s22"}, {10, "r22"}}}, 
        {30, {{5, "s32"}}}, 
        {31, {{2, "s28"}, {4, "r6"}, {5, "r6"}, {7, "s27"}}}, 
        {32, {{0, "r18"}, {2, "r18"}, {4, "r18"}, {5, "r18"}, {6, "r18"}, {7, "r18"}, {9, "r18"}, {10, "r18"}, {11, "r18"}}}, 
        {33, {{4, "s35"}, {5, "r3"}}}, 
        {34, {{4, "r16"}, {5, "r16"}}}, 
        {35, {{1, "s13"}, {8, "s15"}, {10, "s10"}}}, 
        {36, {{2, "s28"}, {4, "r4"}, {5, "r4"}, {7, "s27"}}}
    };

    std::unordered_map<int, std::unordered_map<int, int>> _sparse_goto_table = {
        {0, {{5, 2}, {6, 1}}}, 
        {2, {{10, 5}, {13, 3}}}, 
        {6, {{1, 9}, {4, 30}, {9, 11}, {10, 14}, {14, 31}, {15, 12}}}, 
        {7, {{1, 9}, {9, 11}, {10, 14}, {14, 8}, {15, 12}}}, 
        {8, {{0, 24}, {3, 26}}}, 
        {9, {{8, 19}, {12, 20}}}, 
        {13, {{1, 9}, {9, 11}, {10, 14}, {14, 16}, {15, 12}}}, 
        {16, {{0, 24}, {3, 26}}}, 
        {17, {{10, 14}, {15, 18}}}, 
        {19, {{9, 23}, {10, 14}, {15, 12}}}, 
        {24, {{1, 29}, {9, 11}, {10, 14}, {15, 12}}}, 
        {29, {{8, 19}, {12, 20}}}, 
        {31, {{0, 24}, {2, 33}, {3, 26}}}, 
        {33, {{11, 34}}}, 
        {35, {{1, 9}, {9, 11}, {10, 14}, {14, 36}, {15, 12}}}, 
        {36, {{0, 24}, {3, 26}}}
    };
    
    std::unordered_map<int, std::vector<std::string>> _sentence_index_grammar_tuple_mapping = {
        {25, {"0"}},
        {2, {"0"}},
        {9, {"1"}},
        {21, {"0", "1", "2"}},
        {5, {"0", "*1", "2"}},
        {22, {"0", "*1", "2"}},
        {3, {"0", "*1"}},
        {4, {"1"}},
        {6, {}},
        {16, {"*0", "*1"}},
        {18, {"0", "2"}},
        {7, {"0", "2"}},
        {19, {}},
        {10, {"*0", "1"}}
    };

    std::vector<int> _reduce_symbol_count = {1, 1, 1, 2, 2, 3, 0, 3, 1, 3, 2, 1, 1, 1, 1, 1, 2, 1, 4, 0, 1, 3, 3, 1, 1, 1, 1};

    std::vector<int> _reduce_non_terminal_index = {7, 6, 15, 4, 11, 1, 2, 13, 14, 15, 5, 13, 12, 3, 9, 15, 2, 12, 10, 5, 3, 9, 14, 0, 8, 15, 1};

    std::set<int> _none_grammar_tuple_reduce_set = {0, 1, 8, 11, 12, 13, 14, 15, 17, 20, 23, 24, 26};
};


template <class T>
class SemanticsAnalyzer {
public:
    using semantic_function = std::function<BosonSemanticsNode<T>(BosonSemanticsNode<T> &)>;

    SemanticsAnalyzer() = default;

    BosonSemanticsNode<T> semantics_analysis(BosonGrammarNode &grammar_tree) {
        return this->_semantics_analysis(grammar_tree);
    }

    static BosonSemanticsNode<T> default_semantics_entity(BosonSemanticsNode<T> &semantics_node) {
        return semantics_node;
    }

    static BosonSemanticsNode<T> naive_semantics_entity(BosonSemanticsNode<T> &semantics_node) {
        if (semantics_node.children().size() == 1) {
            return semantics_node[0];
        } else {
            return semantics_node;
        }
    }

    void semantics_entity(int reduce_number, semantic_function function) {
        std::string reduce_name = "!grammar_" + std::to_string(reduce_number);
        this->semantics_entity(reduce_name, function);
    }

    void semantics_entity(const char *reduce_name, semantic_function function) {
        std::string reduce_name_string(reduce_name);
        this->semantics_entity(reduce_name_string, function);
    }

    void semantics_entity(std::string &reduce_name, semantic_function function) {
        this->_semantics_entity[reduce_name] = function;
    }

private:
    std::unordered_map<int, std::string> _reduce_number_grammar_name_mapping = {
        {7, "set_variable"}, 
        {18, "function"}, 
        {22, "compute"}, 
        {5, "compute"}, 
        {21, "compute"}, 
        {9, "expression"}, 
        {2, "get_variable"}, 
        {25, "number"}
    };

    std::set<int> _naive_reduce_number_set = {2, 8, 11, 12, 13, 14, 15, 17, 20, 25, 26};

    std::unordered_map<std::string, semantic_function> _semantics_entity{};

    BosonSemanticsNode<T> _semantics_analysis(BosonGrammarNode &grammar_tree) {
        std::string grammar_name{};
        if (this->_reduce_number_grammar_name_mapping.count(grammar_tree.get_reduce_number())) {
            grammar_name = this->_reduce_number_grammar_name_mapping[grammar_tree.get_reduce_number()];
        } else {
            grammar_name = "!grammar_hidden";
        }
        BosonSemanticsNode<T> semantics_node;
        for (auto &node: grammar_tree.children()) {
            if (!node.children().empty()) {
                semantics_node.append(this->_semantics_analysis(node));
            } else {
                BosonSemanticsNode<T> temp_node;
                temp_node.set_reduce_number(node.get_reduce_number());
                temp_node.set_text(node.get_text());
                semantics_node.append(temp_node);
            }
        }
        if (this->_semantics_entity.count(grammar_name)) {
            return this->_semantics_entity[grammar_name](semantics_node);
        } else if (this->_naive_reduce_number_set.count(grammar_tree.get_reduce_number())) {
            return SemanticsAnalyzer::naive_semantics_entity(semantics_node);
        } else {
            return SemanticsAnalyzer::default_semantics_entity(semantics_node);
        }
    }
};
