/*
    Boson v1.5 - Grammar analyzer generator

        Author: ict
        Email:  ictxiangxin@hotmail.com
        Site:   https://github.com/ictxiangxin/boson

    File: "parser.hpp"
    These codes ware generated by the boson C++ code generator.
*/

#ifndef _BOSON_PARSER_HPP_
#define _BOSON_PARSER_HPP_

#include <vector>
#include <stack>
#include <set>
#include <unordered_map>
#include "token.hpp"
#include "grammar.hpp"
#include "grammar_node.hpp"

namespace boson {
    class Parser {
    public:
        Parser() = default;

        BosonGrammar parse(std::vector<Token> token_list) {
            BosonGrammar grammar;
            std::stack<int> analysis_stack;
            std::stack<BosonGrammarNode> symbol_stack;
            analysis_stack.push(0);
            int token_index = 0;
            while (token_index < token_list.size()) {
                Token &token = token_list[token_index];
                int current_state = analysis_stack.top();
                std::string operation = "e";
                int terminal_index = this->_terminal_index_mapping[token.symbol];
                if (this->_sparse_action_table.count(current_state)) {
                    std::unordered_map<int, std::string> &actions = this->_sparse_action_table[current_state];
                    if (actions.count(terminal_index)) {
                        operation = actions[terminal_index];
                    }
                }
                char operation_flag = operation[0];
                if (operation_flag == 'e') {
                    grammar.set_error_index(token_index);
                    return grammar;
                } else if (operation_flag == 's') {
                    int state_number = (int) strtol(operation.c_str() + 1, nullptr, 10);
                    analysis_stack.push(state_number);
                    token_index++;
                    BosonGrammarNode grammar_node(token.text);
                    symbol_stack.push(grammar_node);
                } else if (operation_flag == 'r') {
                    int statement_index = (int) strtol(operation.c_str() + 1, nullptr, 10);
                    int reduce_count = this->_reduce_symbol_count[statement_index];
                    for (int i = 0; i < reduce_count; i++) {
                        analysis_stack.pop();
                    }
                    current_state = analysis_stack.top();
                    int current_non_terminal_index_mapping = this->_reduce_non_terminal_index[statement_index];
                    int goto_next_state = -1;
                    if (this->_sparse_goto_table.count(current_state)) {
                        std::unordered_map<int, int> &goto_table = this->_sparse_goto_table[current_state];
                        if (goto_table.count(current_non_terminal_index_mapping)) {
                            goto_next_state = goto_table[current_non_terminal_index_mapping];
                        }
                    }
                    if (goto_next_state == -1) {
                        throw std::runtime_error("Invalid goto action.");
                    }
                    analysis_stack.push(goto_next_state);
                    if (this->_sentence_index_grammar_tuple_mapping.count(statement_index)) {
                        std::vector<BosonGrammarNode> symbol_package{};
                        for (int i = 0; i < reduce_count; i++) {
                            symbol_package.insert(symbol_package.begin(), symbol_stack.top());
                            symbol_stack.pop();
                        }
                        BosonGrammarNode grammar_node;
                        for (std::string &node_string : this->_sentence_index_grammar_tuple_mapping[statement_index]) {
                            if (node_string[0] == '*') {
                                int reduce_number = (int) strtol(node_string.c_str() + 1, nullptr, 10);
                                for (BosonGrammarNode &node : symbol_package[reduce_number].children()) {
                                    grammar_node.append(node);
                                }
                            } else {
                                int reduce_number = (int) strtol(node_string.c_str(), nullptr, 10);
                                grammar_node.append(symbol_package[reduce_number]);
                            }
                        }
                        grammar_node.set_reduce_number(statement_index);
                        symbol_stack.push(grammar_node);
                    } else if (this->_non_grammar_tuple_reduce_set.count(statement_index)) {
                        BosonGrammarNode grammar_node;
                        for (int i = 0; i < reduce_count; i++) {
                            grammar_node.insert(0, symbol_stack.top());
                            symbol_stack.pop();
                        }
                        grammar_node.set_reduce_number(statement_index);
                        symbol_stack.push(grammar_node);
                    } else {
                        throw std::runtime_error("Invalid reduce number.");
                    }
                } else if (operation_flag == 'a') {
                    grammar.set_grammar_tree(symbol_stack.top());
                    return grammar;
                } else {
                    throw std::runtime_error("Invalid action.");
                }
            }
            throw std::runtime_error("Analyzer unusual exit.");
        }

    private:
        std::unordered_map<std::string, int> _terminal_index_mapping = {
            {"!symbol_8", 0},
            {"!symbol_1", 1},
            {"!symbol_3", 2},
            {"$", 3},
            {"!symbol_7", 4},
            {"t_number", 5},
            {"!symbol_4", 6},
            {"!symbol_2", 7},
            {"t_symbol", 8},
            {"!symbol_9", 9},
            {"!symbol_5", 10},
            {"!symbol_6", 11}
        };
        std::unordered_map<int, std::unordered_map<int, std::string>> _sparse_action_table = {
            {0, {{3, "r20"}, {8, "r20"}}}, 
            {1, {{3, "a"}}}, 
            {2, {{3, "r24"}, {8, "s3"}}}, 
            {3, {{1, "s7"}, {7, "s6"}}}, 
            {4, {{3, "r9"}, {8, "r9"}}}, 
            {5, {{3, "r12"}, {8, "r12"}}}, 
            {6, {{5, "s13"}, {7, "s14"}, {8, "s8"}}}, 
            {7, {{5, "s13"}, {7, "s14"}, {8, "s8"}}}, 
            {8, {{0, "r16"}, {2, "r16"}, {3, "r16"}, {4, "r16"}, {6, "r16"}, {7, "s6"}, {8, "r16"}, {9, "r16"}, {10, "r16"}, {11, "r16"}}}, 
            {9, {{3, "r11"}, {8, "r11"}, {10, "s18"}, {11, "s17"}}}, 
            {10, {{0, "s24"}, {2, "r3"}, {3, "r3"}, {4, "s23"}, {6, "r3"}, {8, "r3"}, {10, "r3"}, {11, "r3"}}}, 
            {11, {{0, "r21"}, {2, "r21"}, {3, "r21"}, {4, "r21"}, {6, "r21"}, {8, "r21"}, {9, "s28"}, {10, "r21"}, {11, "r21"}}}, 
            {12, {{0, "r1"}, {2, "r1"}, {3, "r1"}, {4, "r1"}, {6, "r1"}, {8, "r1"}, {9, "r1"}, {10, "r1"}, {11, "r1"}}}, 
            {13, {{0, "r13"}, {2, "r13"}, {3, "r13"}, {4, "r13"}, {6, "r13"}, {8, "r13"}, {9, "r13"}, {10, "r13"}, {11, "r13"}}}, 
            {14, {{5, "s13"}, {7, "s14"}, {8, "s8"}}}, 
            {15, {{0, "r25"}, {2, "r25"}, {3, "r25"}, {4, "r25"}, {6, "r25"}, {8, "r25"}, {9, "r25"}, {10, "r25"}, {11, "r25"}}}, 
            {16, {{2, "s19"}, {10, "s18"}, {11, "s17"}}}, 
            {17, {{5, "r8"}, {7, "r8"}, {8, "r8"}}}, 
            {18, {{5, "r23"}, {7, "r23"}, {8, "r23"}}}, 
            {19, {{0, "r19"}, {2, "r19"}, {3, "r19"}, {4, "r19"}, {6, "r19"}, {8, "r19"}, {9, "r19"}, {10, "r19"}, {11, "r19"}}}, 
            {20, {{5, "s13"}, {7, "s14"}, {8, "s8"}}}, 
            {21, {{5, "r14"}, {7, "r14"}, {8, "r14"}}}, 
            {22, {{0, "s24"}, {2, "r7"}, {3, "r7"}, {4, "s23"}, {6, "r7"}, {8, "r7"}, {10, "r7"}, {11, "r7"}}}, 
            {23, {{5, "r2"}, {7, "r2"}, {8, "r2"}}}, 
            {24, {{5, "r6"}, {7, "r6"}, {8, "r6"}}}, 
            {25, {{5, "s13"}, {7, "s14"}, {8, "s8"}}}, 
            {26, {{5, "r4"}, {7, "r4"}, {8, "r4"}}}, 
            {27, {{0, "r5"}, {2, "r5"}, {3, "r5"}, {4, "r5"}, {6, "r5"}, {8, "r5"}, {9, "s28"}, {10, "r5"}, {11, "r5"}}}, 
            {28, {{5, "s13"}, {7, "s14"}, {8, "s8"}}}, 
            {29, {{0, "r22"}, {2, "r22"}, {3, "r22"}, {4, "r22"}, {6, "r22"}, {8, "r22"}, {9, "r22"}, {10, "r22"}, {11, "r22"}}}, 
            {30, {{2, "s36"}}}, 
            {31, {{2, "r26"}, {6, "r26"}, {10, "s18"}, {11, "s17"}}}, 
            {32, {{2, "r15"}, {6, "s34"}}}, 
            {33, {{2, "r10"}, {6, "r10"}}}, 
            {34, {{5, "s13"}, {7, "s14"}, {8, "s8"}}}, 
            {35, {{2, "r17"}, {6, "r17"}, {10, "s18"}, {11, "s17"}}}, 
            {36, {{0, "r18"}, {2, "r18"}, {3, "r18"}, {4, "r18"}, {6, "r18"}, {8, "r18"}, {9, "r18"}, {10, "r18"}, {11, "r18"}}}
        };
        std::unordered_map<int, std::unordered_map<int, int>> _sparse_goto_table = {
            {0, {{7, 2}, {8, 1}}}, 
            {2, {{4, 5}, {9, 4}}}, 
            {6, {{1, 11}, {4, 15}, {5, 30}, {6, 31}, {12, 12}, {15, 10}}}, 
            {7, {{1, 11}, {4, 15}, {6, 9}, {12, 12}, {15, 10}}}, 
            {9, {{3, 21}, {14, 20}}}, 
            {10, {{2, 25}, {10, 26}}}, 
            {14, {{1, 11}, {4, 15}, {6, 16}, {12, 12}, {15, 10}}}, 
            {16, {{3, 21}, {14, 20}}}, 
            {20, {{1, 11}, {4, 15}, {12, 12}, {15, 22}}}, 
            {22, {{2, 25}, {10, 26}}}, 
            {25, {{1, 27}, {4, 15}, {12, 12}}}, 
            {28, {{4, 15}, {12, 29}}}, 
            {31, {{3, 21}, {11, 32}, {14, 20}}}, 
            {32, {{0, 33}}}, 
            {34, {{1, 11}, {4, 15}, {6, 35}, {12, 12}, {15, 10}}}, 
            {35, {{3, 21}, {14, 20}}}
        };
        std::unordered_map<int, std::vector<std::string>> _sentence_index_grammar_tuple_mapping = {
            {13, {"0"}},
            {16, {"0"}},
            {19, {"1"}},
            {22, {"0", "1", "2"}},
            {5, {"0", "*1", "2"}},
            {7, {"0", "*1", "2"}},
            {15, {"0", "*1"}},
            {17, {"1"}},
            {26, {}},
            {10, {"*0", "*1"}},
            {18, {"0", "2"}},
            {11, {"0", "2"}},
            {20, {}},
            {9, {"*0", "1"}}
        };
        std::vector<int> _reduce_symbol_count = {1, 1, 1, 1, 1, 3, 1, 3, 1, 2, 2, 3, 1, 1, 1, 2, 1, 2, 4, 3, 0, 1, 3, 1, 1, 1, 0};
        std::vector<int> _reduce_non_terminal_index = {13, 1, 10, 6, 2, 15, 10, 6, 3, 7, 11, 9, 9, 12, 14, 5, 12, 0, 4, 12, 7, 15, 1, 3, 8, 12, 11};
        std::set<int> _non_grammar_tuple_reduce_set = {0, 1, 2, 3, 4, 6, 8, 12, 14, 21, 23, 24, 25};
    };
}

#endif
