/*
    Boson v1.5 - Grammar analyzer generator

        Author: ict
        Email:  ictxiangxin@hotmail.com
        Site:   https://github.com/ictxiangxin/boson

    File: "parser.hpp"
    These codes ware generated by the boson C++ code generator.
*/

#ifndef _BOSON_PARSER_HPP_
#define _BOSON_PARSER_HPP_

#include <vector>
#include <stack>
#include <set>
#include <unordered_map>
#include "token.hpp"
#include "grammar.hpp"
#include "grammar_node.hpp"

namespace boson {
    class Parser {
    public:
        Parser() = default;

        BosonGrammar parse(std::vector<Token> token_list) {
            BosonGrammar grammar;
            std::stack<int> analysis_stack;
            std::stack<BosonGrammarNode> symbol_stack;
            analysis_stack.push(0);
            int token_index = 0;
            while (token_index < token_list.size()) {
                Token &token = token_list[token_index];
                int current_state = analysis_stack.top();
                std::string operation = "e";
                int terminal_index = this->_terminal_index_mapping[token.symbol];
                if (this->_sparse_action_table.count(current_state)) {
                    std::unordered_map<int, std::string> &actions = this->_sparse_action_table[current_state];
                    if (actions.count(terminal_index)) {
                        operation = actions[terminal_index];
                    }
                }
                char operation_flag = operation[0];
                if (operation_flag == 'e') {
                    grammar.set_error_index(token_index);
                    return grammar;
                } else if (operation_flag == 's') {
                    int state_number = (int) strtol(operation.c_str() + 1, nullptr, 10);
                    analysis_stack.push(state_number);
                    token_index++;
                    BosonGrammarNode grammar_node(token.text);
                    symbol_stack.push(grammar_node);
                } else if (operation_flag == 'r') {
                    int statement_index = (int) strtol(operation.c_str() + 1, nullptr, 10);
                    int reduce_count = this->_reduce_symbol_count[statement_index];
                    for (int i = 0; i < reduce_count; i++) {
                        analysis_stack.pop();
                    }
                    current_state = analysis_stack.top();
                    int current_non_terminal_index_mapping = this->_reduce_non_terminal_index[statement_index];
                    int goto_next_state = -1;
                    if (this->_sparse_goto_table.count(current_state)) {
                        std::unordered_map<int, int> &goto_table = this->_sparse_goto_table[current_state];
                        if (goto_table.count(current_non_terminal_index_mapping)) {
                            goto_next_state = goto_table[current_non_terminal_index_mapping];
                        }
                    }
                    if (goto_next_state == -1) {
                        throw std::runtime_error("Invalid goto action.");
                    }
                    analysis_stack.push(goto_next_state);
                    if (this->_sentence_index_grammar_tuple_mapping.count(statement_index)) {
                        std::vector<BosonGrammarNode> symbol_package{};
                        for (int i = 0; i < reduce_count; i++) {
                            symbol_package.insert(symbol_package.begin(), symbol_stack.top());
                            symbol_stack.pop();
                        }
                        BosonGrammarNode grammar_node;
                        for (std::string &node_string : this->_sentence_index_grammar_tuple_mapping[statement_index]) {
                            if (node_string[0] == '*') {
                                int reduce_number = (int) strtol(node_string.c_str() + 1, nullptr, 10);
                                for (BosonGrammarNode &node : symbol_package[reduce_number].children()) {
                                    grammar_node.append(node);
                                }
                            } else {
                                int reduce_number = (int) strtol(node_string.c_str(), nullptr, 10);
                                grammar_node.append(symbol_package[reduce_number]);
                            }
                        }
                        grammar_node.set_reduce_number(statement_index);
                        symbol_stack.push(grammar_node);
                    } else if (this->_none_grammar_tuple_reduce_set.count(statement_index)) {
                        BosonGrammarNode grammar_node;
                        for (int i = 0; i < reduce_count; i++) {
                            grammar_node.insert(0, symbol_stack.top());
                            symbol_stack.pop();
                        }
                        grammar_node.set_reduce_number(statement_index);
                        symbol_stack.push(grammar_node);
                    } else {
                        throw std::runtime_error("Invalid reduce number.");
                    }
                } else if (operation_flag == 'a') {
                    grammar.set_grammar_tree(symbol_stack.top());
                    return grammar;
                } else {
                    throw std::runtime_error("Invalid action.");
                }
            }
            throw std::runtime_error("Analyzer unusual exit.");
        }

    private:
        std::unordered_map<std::string, int>_terminal_index_mapping = {
            {"t_number", 0},
            {"t_symbol", 1},
            {"!symbol_3", 2},
            {"!symbol_5", 3},
            {"$", 4},
            {"!symbol_7", 5},
            {"!symbol_4", 6},
            {"!symbol_1", 7},
            {"!symbol_9", 8},
            {"!symbol_6", 9},
            {"!symbol_8", 10},
            {"!symbol_2", 11}
        };
        std::unordered_map<int, std::unordered_map<int, std::string>> _sparse_action_table = {
            {0, {{1, "r11"}, {4, "r11"}}}, 
            {1, {{4, "a"}}}, 
            {2, {{1, "s3"}, {4, "r16"}}}, 
            {3, {{7, "s7"}, {11, "s6"}}}, 
            {4, {{1, "r7"}, {4, "r7"}}}, 
            {5, {{1, "r24"}, {4, "r24"}}}, 
            {6, {{0, "s14"}, {1, "s8"}, {11, "s15"}}}, 
            {7, {{0, "s14"}, {1, "s8"}, {11, "s15"}}}, 
            {8, {{1, "r21"}, {2, "r21"}, {3, "r21"}, {4, "r21"}, {5, "r21"}, {6, "r21"}, {8, "r21"}, {9, "r21"}, {10, "r21"}, {11, "s6"}}}, 
            {9, {{1, "r14"}, {3, "s17"}, {4, "r14"}, {9, "s18"}}}, 
            {10, {{1, "r3"}, {2, "r3"}, {3, "r3"}, {4, "r3"}, {5, "s26"}, {6, "r3"}, {9, "r3"}, {10, "s25"}}}, 
            {11, {{1, "r5"}, {2, "r5"}, {3, "r5"}, {4, "r5"}, {5, "r5"}, {6, "r5"}, {8, "s28"}, {9, "r5"}, {10, "r5"}}}, 
            {12, {{1, "r17"}, {2, "r17"}, {3, "r17"}, {4, "r17"}, {5, "r17"}, {6, "r17"}, {8, "r17"}, {9, "r17"}, {10, "r17"}}}, 
            {13, {{1, "r12"}, {2, "r12"}, {3, "r12"}, {4, "r12"}, {5, "r12"}, {6, "r12"}, {8, "r12"}, {9, "r12"}, {10, "r12"}}}, 
            {14, {{1, "r19"}, {2, "r19"}, {3, "r19"}, {4, "r19"}, {5, "r19"}, {6, "r19"}, {8, "r19"}, {9, "r19"}, {10, "r19"}}}, 
            {15, {{0, "s14"}, {1, "s8"}, {11, "s15"}}}, 
            {16, {{2, "s21"}, {3, "s17"}, {9, "s18"}}}, 
            {17, {{0, "r10"}, {1, "r10"}, {11, "r10"}}}, 
            {18, {{0, "r13"}, {1, "r13"}, {11, "r13"}}}, 
            {19, {{0, "s14"}, {1, "s8"}, {11, "s15"}}}, 
            {20, {{0, "r15"}, {1, "r15"}, {11, "r15"}}}, 
            {21, {{1, "r20"}, {2, "r20"}, {3, "r20"}, {4, "r20"}, {5, "r20"}, {6, "r20"}, {8, "r20"}, {9, "r20"}, {10, "r20"}}}, 
            {22, {{1, "r4"}, {2, "r4"}, {3, "r4"}, {4, "r4"}, {5, "s26"}, {6, "r4"}, {9, "r4"}, {10, "s25"}}}, 
            {23, {{0, "s14"}, {1, "s8"}, {11, "s15"}}}, 
            {24, {{0, "r26"}, {1, "r26"}, {11, "r26"}}}, 
            {25, {{0, "r9"}, {1, "r9"}, {11, "r9"}}}, 
            {26, {{0, "r25"}, {1, "r25"}, {11, "r25"}}}, 
            {27, {{1, "r23"}, {2, "r23"}, {3, "r23"}, {4, "r23"}, {5, "r23"}, {6, "r23"}, {8, "s28"}, {9, "r23"}, {10, "r23"}}}, 
            {28, {{0, "s14"}, {1, "s8"}, {11, "s15"}}}, 
            {29, {{1, "r6"}, {2, "r6"}, {3, "r6"}, {4, "r6"}, {5, "r6"}, {6, "r6"}, {8, "r6"}, {9, "r6"}, {10, "r6"}}}, 
            {30, {{2, "s36"}}}, 
            {31, {{2, "r1"}, {3, "s17"}, {6, "r1"}, {9, "s18"}}}, 
            {32, {{2, "r2"}, {6, "s34"}}}, 
            {33, {{2, "r22"}, {6, "r22"}}}, 
            {34, {{0, "s14"}, {1, "s8"}, {11, "s15"}}}, 
            {35, {{2, "r18"}, {3, "s17"}, {6, "r18"}, {9, "s18"}}}, 
            {36, {{1, "r8"}, {2, "r8"}, {3, "r8"}, {4, "r8"}, {5, "r8"}, {6, "r8"}, {8, "r8"}, {9, "r8"}, {10, "r8"}}}
        };
        std::unordered_map<int, std::unordered_map<int, int>> _sparse_goto_table = {
            {0, {{2, 1}, {15, 2}}}, 
            {2, {{13, 4}, {14, 5}}}, 
            {6, {{0, 11}, {1, 30}, {6, 31}, {7, 12}, {12, 10}, {14, 13}}}, 
            {7, {{0, 11}, {6, 9}, {7, 12}, {12, 10}, {14, 13}}}, 
            {9, {{3, 19}, {11, 20}}}, 
            {10, {{5, 24}, {10, 23}}}, 
            {15, {{0, 11}, {6, 16}, {7, 12}, {12, 10}, {14, 13}}}, 
            {16, {{3, 19}, {11, 20}}}, 
            {19, {{0, 11}, {7, 12}, {12, 22}, {14, 13}}}, 
            {22, {{5, 24}, {10, 23}}}, 
            {23, {{0, 27}, {7, 12}, {14, 13}}}, 
            {28, {{7, 29}, {14, 13}}}, 
            {31, {{3, 19}, {8, 32}, {11, 20}}}, 
            {32, {{9, 33}}}, 
            {34, {{0, 11}, {6, 35}, {7, 12}, {12, 10}, {14, 13}}}, 
            {35, {{3, 19}, {11, 20}}}
        };
        std::unordered_map<int, std::vector<std::string>> _sentence_index_grammar_tuple_mapping = {
            {19, {"0"}},
            {21, {"0"}},
            {20, {"1"}},
            {6, {"0", "1", "2"}},
            {23, {"0", "*1", "2"}},
            {4, {"0", "*1", "2"}},
            {2, {"0", "*1"}},
            {18, {"1"}},
            {1, {}},
            {22, {"*0", "*1"}},
            {8, {"0", "2"}},
            {14, {"0", "2"}},
            {11, {}},
            {7, {"*0", "1"}}
        };
        std::vector<int> _reduce_symbol_count = {1, 0, 2, 1, 3, 1, 3, 2, 4, 1, 1, 0, 1, 1, 3, 1, 1, 1, 2, 1, 3, 1, 2, 3, 1, 1, 1};
        std::vector<int> _reduce_non_terminal_index = {4, 8, 1, 6, 6, 12, 0, 15, 14, 5, 11, 15, 7, 11, 13, 3, 2, 0, 9, 7, 7, 7, 8, 12, 13, 5, 10};
        std::set<int> _none_grammar_tuple_reduce_set = {0, 3, 5, 9, 10, 12, 13, 15, 16, 17, 24, 25, 26};
    };
}

#endif
