/*
    Boson v1.5 - Grammar analyzer generator

        Author: ict
        Email:  ictxiangxin@hotmail.com
        Site:   https://github.com/ictxiangxin/boson

    File: "parser.hpp"
    These codes ware generated by the boson C++ code generator.
*/

#ifndef _BOSON_PARSER_HPP_
#define _BOSON_PARSER_HPP_

#include <vector>
#include <stack>
#include <set>
#include <unordered_map>
#include "token.hpp"
#include "grammar.hpp"
#include "grammar_node.hpp"

namespace boson {
    class Parser {
    public:
        Parser() = default;

        BosonGrammar parse(std::vector<Token> token_list) {
            BosonGrammar grammar;
            std::stack<int> analysis_stack;
            std::stack<BosonGrammarNode> symbol_stack;
            analysis_stack.push(0);
            int token_index = 0;
            while (token_index < token_list.size()) {
                Token &token = token_list[token_index];
                int current_state = analysis_stack.top();
                std::string operation = "e";
                int terminal_index = this->_terminal_index_mapping[token.symbol];
                if (this->_sparse_action_table.count(current_state)) {
                    std::unordered_map<int, std::string> &actions = this->_sparse_action_table[current_state];
                    if (actions.count(terminal_index)) {
                        operation = actions[terminal_index];
                    }
                }
                char operation_flag = operation[0];
                if (operation_flag == 'e') {
                    grammar.set_error_index(token_index);
                    return grammar;
                } else if (operation_flag == 's') {
                    int state_number = (int) strtol(operation.c_str() + 1, nullptr, 10);
                    analysis_stack.push(state_number);
                    token_index++;
                    BosonGrammarNode grammar_node(token.text);
                    symbol_stack.push(grammar_node);
                } else if (operation_flag == 'r') {
                    int statement_index = (int) strtol(operation.c_str() + 1, nullptr, 10);
                    int reduce_count = this->_reduce_symbol_count[statement_index];
                    for (int i = 0; i < reduce_count; i++) {
                        analysis_stack.pop();
                    }
                    current_state = analysis_stack.top();
                    int current_non_terminal_index_mapping = this->_reduce_non_terminal_index[statement_index];
                    int goto_next_state = -1;
                    if (this->_sparse_goto_table.count(current_state)) {
                        std::unordered_map<int, int> &goto_table = this->_sparse_goto_table[current_state];
                        if (goto_table.count(current_non_terminal_index_mapping)) {
                            goto_next_state = goto_table[current_non_terminal_index_mapping];
                        }
                    }
                    if (goto_next_state == -1) {
                        throw std::runtime_error("Invalid goto action.");
                    }
                    analysis_stack.push(goto_next_state);
                    if (this->_sentence_index_grammar_tuple_mapping.count(statement_index)) {
                        std::vector<BosonGrammarNode> symbol_package{};
                        for (int i = 0; i < reduce_count; i++) {
                            symbol_package.insert(symbol_package.begin(), symbol_stack.top());
                            symbol_stack.pop();
                        }
                        BosonGrammarNode grammar_node;
                        for (std::string &node_string : this->_sentence_index_grammar_tuple_mapping[statement_index]) {
                            if (node_string[0] == '*') {
                                int reduce_number = (int) strtol(node_string.c_str() + 1, nullptr, 10);
                                for (BosonGrammarNode &node : symbol_package[reduce_number].children()) {
                                    grammar_node.append(node);
                                }
                            } else {
                                int reduce_number = (int) strtol(node_string.c_str(), nullptr, 10);
                                grammar_node.append(symbol_package[reduce_number]);
                            }
                        }
                        grammar_node.set_reduce_number(statement_index);
                        symbol_stack.push(grammar_node);
                    } else if (this->_none_grammar_tuple_reduce_set.count(statement_index)) {
                        BosonGrammarNode grammar_node;
                        for (int i = 0; i < reduce_count; i++) {
                            grammar_node.insert(0, symbol_stack.top());
                            symbol_stack.pop();
                        }
                        grammar_node.set_reduce_number(statement_index);
                        symbol_stack.push(grammar_node);
                    } else {
                        throw std::runtime_error("Invalid reduce number.");
                    }
                } else if (operation_flag == 'a') {
                    grammar.set_grammar_tree(symbol_stack.top());
                    return grammar;
                } else {
                    throw std::runtime_error("Invalid action.");
                }
            }
            throw std::runtime_error("Analyzer unusual exit.");
        }

    private:
        std::unordered_map<std::string, int>_terminal_index_mapping = {
            {"!symbol_2", 0},
            {"!symbol_3", 1},
            {"!symbol_9", 2},
            {"!symbol_4", 3},
            {"!symbol_1", 4},
            {"t_number", 5},
            {"!symbol_5", 6},
            {"!symbol_6", 7},
            {"!symbol_8", 8},
            {"t_symbol", 9},
            {"$", 10},
            {"!symbol_7", 11}
        };
        
        std::unordered_map<int, std::unordered_map<int, std::string>> _sparse_action_table = {
            {0, {{9, "r21"}, {10, "r21"}}}, 
            {1, {{10, "a"}}}, 
            {2, {{9, "s3"}, {10, "r10"}}}, 
            {3, {{0, "s6"}, {4, "s7"}}}, 
            {4, {{9, "r12"}, {10, "r12"}}}, 
            {5, {{9, "r8"}, {10, "r8"}}}, 
            {6, {{0, "s13"}, {5, "s15"}, {9, "s14"}}}, 
            {7, {{0, "s13"}, {5, "s15"}, {9, "s14"}}}, 
            {8, {{6, "s19"}, {7, "s20"}, {9, "r17"}, {10, "r17"}}}, 
            {9, {{1, "r5"}, {3, "r5"}, {6, "r5"}, {7, "r5"}, {8, "s24"}, {9, "r5"}, {10, "r5"}, {11, "s26"}}}, 
            {10, {{1, "r25"}, {2, "s28"}, {3, "r25"}, {6, "r25"}, {7, "r25"}, {8, "r25"}, {9, "r25"}, {10, "r25"}, {11, "r25"}}}, 
            {11, {{1, "r24"}, {2, "r24"}, {3, "r24"}, {6, "r24"}, {7, "r24"}, {8, "r24"}, {9, "r24"}, {10, "r24"}, {11, "r24"}}}, 
            {12, {{1, "r2"}, {2, "r2"}, {3, "r2"}, {6, "r2"}, {7, "r2"}, {8, "r2"}, {9, "r2"}, {10, "r2"}, {11, "r2"}}}, 
            {13, {{0, "s13"}, {5, "s15"}, {9, "s14"}}}, 
            {14, {{0, "s6"}, {1, "r20"}, {2, "r20"}, {3, "r20"}, {6, "r20"}, {7, "r20"}, {8, "r20"}, {9, "r20"}, {10, "r20"}, {11, "r20"}}}, 
            {15, {{1, "r23"}, {2, "r23"}, {3, "r23"}, {6, "r23"}, {7, "r23"}, {8, "r23"}, {9, "r23"}, {10, "r23"}, {11, "r23"}}}, 
            {16, {{1, "s21"}, {6, "s19"}, {7, "s20"}}}, 
            {17, {{0, "s13"}, {5, "s15"}, {9, "s14"}}}, 
            {18, {{0, "r1"}, {5, "r1"}, {9, "r1"}}}, 
            {19, {{0, "r3"}, {5, "r3"}, {9, "r3"}}}, 
            {20, {{0, "r11"}, {5, "r11"}, {9, "r11"}}}, 
            {21, {{1, "r15"}, {2, "r15"}, {3, "r15"}, {6, "r15"}, {7, "r15"}, {8, "r15"}, {9, "r15"}, {10, "r15"}, {11, "r15"}}}, 
            {22, {{1, "r18"}, {3, "r18"}, {6, "r18"}, {7, "r18"}, {8, "s24"}, {9, "r18"}, {10, "r18"}, {11, "s26"}}}, 
            {23, {{0, "s13"}, {5, "s15"}, {9, "s14"}}}, 
            {24, {{0, "r16"}, {5, "r16"}, {9, "r16"}}}, 
            {25, {{0, "r19"}, {5, "r19"}, {9, "r19"}}}, 
            {26, {{0, "r26"}, {5, "r26"}, {9, "r26"}}}, 
            {27, {{1, "r7"}, {2, "s28"}, {3, "r7"}, {6, "r7"}, {7, "r7"}, {8, "r7"}, {9, "r7"}, {10, "r7"}, {11, "r7"}}}, 
            {28, {{0, "s13"}, {5, "s15"}, {9, "s14"}}}, 
            {29, {{1, "r4"}, {2, "r4"}, {3, "r4"}, {6, "r4"}, {7, "r4"}, {8, "r4"}, {9, "r4"}, {10, "r4"}, {11, "r4"}}}, 
            {30, {{1, "r6"}, {3, "r6"}, {6, "s19"}, {7, "s20"}}}, 
            {31, {{1, "s32"}}}, 
            {32, {{1, "r13"}, {2, "r13"}, {3, "r13"}, {6, "r13"}, {7, "r13"}, {8, "r13"}, {9, "r13"}, {10, "r13"}, {11, "r13"}}}, 
            {33, {{1, "r14"}, {3, "s34"}}}, 
            {34, {{0, "s13"}, {5, "s15"}, {9, "s14"}}}, 
            {35, {{1, "r22"}, {3, "r22"}}}, 
            {36, {{1, "r9"}, {3, "r9"}, {6, "s19"}, {7, "s20"}}}
        };

        std::unordered_map<int, std::unordered_map<int, int>> _sparse_goto_table = {
            {0, {{8, 1}, {11, 2}}}, 
            {2, {{3, 5}, {13, 4}}}, 
            {6, {{1, 10}, {2, 9}, {3, 12}, {7, 11}, {9, 31}, {15, 30}}}, 
            {7, {{1, 10}, {2, 9}, {3, 12}, {7, 11}, {15, 8}}}, 
            {8, {{5, 18}, {12, 17}}}, 
            {9, {{4, 25}, {10, 23}}}, 
            {13, {{1, 10}, {2, 9}, {3, 12}, {7, 11}, {15, 16}}}, 
            {16, {{5, 18}, {12, 17}}}, 
            {17, {{1, 10}, {2, 22}, {3, 12}, {7, 11}}}, 
            {22, {{4, 25}, {10, 23}}}, 
            {23, {{1, 27}, {3, 12}, {7, 11}}}, 
            {28, {{3, 12}, {7, 29}}}, 
            {30, {{5, 18}, {12, 17}, {14, 33}}}, 
            {33, {{0, 35}}}, 
            {34, {{1, 10}, {2, 9}, {3, 12}, {7, 11}, {15, 36}}}, 
            {36, {{5, 18}, {12, 17}}}
        };
        
        std::unordered_map<int, std::vector<std::string>> _sentence_index_grammar_tuple_mapping = {
            {23, {"0"}},
            {20, {"0"}},
            {15, {"1"}},
            {4, {"0", "1", "2"}},
            {7, {"0", "*1", "2"}},
            {18, {"0", "*1", "2"}},
            {14, {"0", "*1"}},
            {9, {"1"}},
            {6, {}},
            {22, {"*0", "*1"}},
            {13, {"0", "2"}},
            {17, {"0", "2"}},
            {21, {}},
            {12, {"*0", "1"}}
        };

        std::vector<int> _reduce_symbol_count = {1, 1, 1, 1, 3, 1, 0, 3, 1, 2, 1, 1, 2, 4, 2, 3, 1, 3, 3, 1, 1, 0, 2, 1, 1, 1, 1};

        std::vector<int> _reduce_non_terminal_index = {6, 12, 7, 5, 1, 15, 14, 2, 13, 0, 8, 5, 11, 3, 9, 7, 4, 13, 15, 10, 7, 11, 14, 7, 1, 2, 4};

        std::set<int> _none_grammar_tuple_reduce_set = {0, 1, 2, 3, 5, 8, 10, 11, 16, 19, 24, 25, 26};
    };
}

#endif
