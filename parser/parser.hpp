/*
    Boson v1.5 - Grammar analyzer generator

        Author: ict
        Email:  ictxiangxin@hotmail.com
        Site:   https://github.com/ictxiangxin/boson

    File: "parser.hpp"
    These codes ware generated by the boson C++ code generator.
*/

#ifndef _BOSON_PARSER_HPP_
#define _BOSON_PARSER_HPP_

#include <vector>
#include <stack>
#include <set>
#include <unordered_map>
#include "token.hpp"
#include "grammar.hpp"
#include "grammar_node.hpp"

namespace boson {
    class Parser {
    public:
        Parser() = default;

        BosonGrammar parse(std::vector<Token> token_list) {
            BosonGrammar grammar;
            std::stack<int> analysis_stack;
            std::stack<BosonGrammarNode> symbol_stack;
            analysis_stack.push(0);
            int token_index = 0;
            while (token_index < token_list.size()) {
                Token &token = token_list[token_index];
                int current_state = analysis_stack.top();
                std::string operation = "e";
                if (this->_terminal_index_mapping.count(token.symbol)) {
                    int terminal_index = this->_terminal_index_mapping[token.symbol];
                    if (this->_sparse_action_table.count(current_state)) {
                        std::unordered_map<int, std::string> &actions = this->_sparse_action_table[current_state];
                        if (actions.count(terminal_index)) {
                            operation = actions[terminal_index];
                        }
                    }
                }
                char operation_flag = operation[0];
                if (operation_flag == 'e') {
                    grammar.set_error_index(token_index);
                    return grammar;
                } else if (operation_flag == 's') {
                    int state_number = (int) strtol(operation.c_str() + 1, nullptr, 10);
                    analysis_stack.push(state_number);
                    token_index++;
                    BosonGrammarNode grammar_node(token.text);
                    symbol_stack.push(grammar_node);
                } else if (operation_flag == 'r') {
                    int statement_index = (int) strtol(operation.c_str() + 1, nullptr, 10);
                    int reduce_count = this->_reduce_symbol_count[statement_index];
                    for (int i = 0; i < reduce_count; i++) {
                        analysis_stack.pop();
                    }
                    current_state = analysis_stack.top();
                    int current_non_terminal_index_mapping = this->_reduce_non_terminal_index[statement_index];
                    int goto_next_state = -1;
                    if (this->_sparse_goto_table.count(current_state)) {
                        std::unordered_map<int, int> &goto_table = this->_sparse_goto_table[current_state];
                        if (goto_table.count(current_non_terminal_index_mapping)) {
                            goto_next_state = goto_table[current_non_terminal_index_mapping];
                        }
                    }
                    if (goto_next_state == -1) {
                        throw std::runtime_error("Invalid goto action.");
                    }
                    analysis_stack.push(goto_next_state);
                    if (this->_sentence_index_grammar_tuple_mapping.count(statement_index)) {
                        std::vector<BosonGrammarNode> symbol_package{};
                        for (int i = 0; i < reduce_count; i++) {
                            symbol_package.insert(symbol_package.begin(), symbol_stack.top());
                            symbol_stack.pop();
                        }
                        BosonGrammarNode grammar_node;
                        for (std::string &node_string : this->_sentence_index_grammar_tuple_mapping[statement_index]) {
                            if (node_string[0] == '*') {
                                int reduce_number = (int) strtol(node_string.c_str() + 1, nullptr, 10);
                                for (BosonGrammarNode &node : symbol_package[reduce_number].children()) {
                                    grammar_node.append(node);
                                }
                            } else {
                                int reduce_number = (int) strtol(node_string.c_str(), nullptr, 10);
                                grammar_node.append(symbol_package[reduce_number]);
                            }
                        }
                        grammar_node.set_reduce_number(statement_index);
                        symbol_stack.push(grammar_node);
                    } else if (this->_non_grammar_tuple_reduce_set.count(statement_index)) {
                        BosonGrammarNode grammar_node;
                        for (int i = 0; i < reduce_count; i++) {
                            grammar_node.insert(0, symbol_stack.top());
                            symbol_stack.pop();
                        }
                        grammar_node.set_reduce_number(statement_index);
                        symbol_stack.push(grammar_node);
                    } else {
                        throw std::runtime_error("Invalid reduce number.");
                    }
                } else if (operation_flag == 'a') {
                    grammar.set_grammar_tree(symbol_stack.top());
                    return grammar;
                } else {
                    throw std::runtime_error("Invalid action.");
                }
            }
            throw std::runtime_error("Analyzer unusual exit.");
        }

    private:
        std::unordered_map<std::string, int> _terminal_index_mapping = {
            {"t_symbol", 0},
            {"!symbol_4", 1},
            {"!symbol_8", 2},
            {"$", 3},
            {"!symbol_7", 4},
            {"!symbol_3", 5},
            {"!symbol_5", 6},
            {"!symbol_2", 7},
            {"t_number", 8},
            {"!symbol_9", 9},
            {"!symbol_1", 10},
            {"!symbol_6", 11}
        };
        std::unordered_map<int, std::unordered_map<int, std::string>> _sparse_action_table = {
            {0, {{0, "r18"}, {3, "r18"}}}, 
            {1, {{3, "a"}}}, 
            {2, {{0, "s3"}, {3, "r20"}}}, 
            {3, {{7, "s6"}, {10, "s7"}}}, 
            {4, {{0, "r22"}, {3, "r22"}}}, 
            {5, {{0, "r23"}, {3, "r23"}}}, 
            {6, {{0, "s8"}, {7, "s15"}, {8, "s13"}}}, 
            {7, {{0, "s8"}, {7, "s15"}, {8, "s13"}}}, 
            {8, {{0, "r24"}, {1, "r24"}, {2, "r24"}, {3, "r24"}, {4, "r24"}, {5, "r24"}, {6, "r24"}, {7, "s6"}, {9, "r24"}, {11, "r24"}}}, 
            {9, {{0, "r15"}, {3, "r15"}, {6, "s17"}, {11, "s18"}}}, 
            {10, {{0, "r3"}, {1, "r3"}, {2, "s26"}, {3, "r3"}, {4, "s25"}, {5, "r3"}, {6, "r3"}, {11, "r3"}}}, 
            {11, {{0, "r5"}, {1, "r5"}, {2, "r5"}, {3, "r5"}, {4, "r5"}, {5, "r5"}, {6, "r5"}, {9, "s28"}, {11, "r5"}}}, 
            {12, {{0, "r21"}, {1, "r21"}, {2, "r21"}, {3, "r21"}, {4, "r21"}, {5, "r21"}, {6, "r21"}, {9, "r21"}, {11, "r21"}}}, 
            {13, {{0, "r14"}, {1, "r14"}, {2, "r14"}, {3, "r14"}, {4, "r14"}, {5, "r14"}, {6, "r14"}, {9, "r14"}, {11, "r14"}}}, 
            {14, {{0, "r19"}, {1, "r19"}, {2, "r19"}, {3, "r19"}, {4, "r19"}, {5, "r19"}, {6, "r19"}, {9, "r19"}, {11, "r19"}}}, 
            {15, {{0, "s8"}, {7, "s15"}, {8, "s13"}}}, 
            {16, {{5, "s21"}, {6, "s17"}, {11, "s18"}}}, 
            {17, {{0, "r7"}, {7, "r7"}, {8, "r7"}}}, 
            {18, {{0, "r12"}, {7, "r12"}, {8, "r12"}}}, 
            {19, {{0, "r4"}, {7, "r4"}, {8, "r4"}}}, 
            {20, {{0, "s8"}, {7, "s15"}, {8, "s13"}}}, 
            {21, {{0, "r25"}, {1, "r25"}, {2, "r25"}, {3, "r25"}, {4, "r25"}, {5, "r25"}, {6, "r25"}, {9, "r25"}, {11, "r25"}}}, 
            {22, {{0, "r11"}, {1, "r11"}, {2, "s26"}, {3, "r11"}, {4, "s25"}, {5, "r11"}, {6, "r11"}, {11, "r11"}}}, 
            {23, {{0, "s8"}, {7, "s15"}, {8, "s13"}}}, 
            {24, {{0, "r16"}, {7, "r16"}, {8, "r16"}}}, 
            {25, {{0, "r17"}, {7, "r17"}, {8, "r17"}}}, 
            {26, {{0, "r26"}, {7, "r26"}, {8, "r26"}}}, 
            {27, {{0, "r10"}, {1, "r10"}, {2, "r10"}, {3, "r10"}, {4, "r10"}, {5, "r10"}, {6, "r10"}, {9, "s28"}, {11, "r10"}}}, 
            {28, {{0, "s8"}, {7, "s15"}, {8, "s13"}}}, 
            {29, {{0, "r2"}, {1, "r2"}, {2, "r2"}, {3, "r2"}, {4, "r2"}, {5, "r2"}, {6, "r2"}, {9, "r2"}, {11, "r2"}}}, 
            {30, {{5, "s36"}}}, 
            {31, {{1, "r8"}, {5, "r8"}, {6, "s17"}, {11, "s18"}}}, 
            {32, {{1, "s34"}, {5, "r13"}}}, 
            {33, {{1, "r6"}, {5, "r6"}}}, 
            {34, {{0, "s8"}, {7, "s15"}, {8, "s13"}}}, 
            {35, {{1, "r9"}, {5, "r9"}, {6, "s17"}, {11, "s18"}}}, 
            {36, {{0, "r1"}, {1, "r1"}, {2, "r1"}, {3, "r1"}, {4, "r1"}, {5, "r1"}, {6, "r1"}, {9, "r1"}, {11, "r1"}}}
        };
        std::unordered_map<int, std::unordered_map<int, int>> _sparse_goto_table = {
            {0, {{6, 2}, {9, 1}}}, 
            {2, {{1, 4}, {3, 5}}}, 
            {6, {{2, 10}, {3, 14}, {7, 30}, {8, 11}, {12, 31}, {13, 12}}}, 
            {7, {{2, 10}, {3, 14}, {8, 11}, {12, 9}, {13, 12}}}, 
            {9, {{10, 20}, {14, 19}}}, 
            {10, {{4, 24}, {15, 23}}}, 
            {15, {{2, 10}, {3, 14}, {8, 11}, {12, 16}, {13, 12}}}, 
            {16, {{10, 20}, {14, 19}}}, 
            {20, {{2, 22}, {3, 14}, {8, 11}, {13, 12}}}, 
            {22, {{4, 24}, {15, 23}}}, 
            {23, {{3, 14}, {8, 27}, {13, 12}}}, 
            {28, {{3, 14}, {13, 29}}}, 
            {31, {{0, 32}, {10, 20}, {14, 19}}}, 
            {32, {{11, 33}}}, 
            {34, {{2, 10}, {3, 14}, {8, 11}, {12, 35}, {13, 12}}}, 
            {35, {{10, 20}, {14, 19}}}
        };
        std::unordered_map<int, std::vector<std::string>> _sentence_index_grammar_tuple_mapping = {
            {14, {"0"}},
            {24, {"0"}},
            {25, {"1"}},
            {2, {"0", "1", "2"}},
            {10, {"0", "*1", "2"}},
            {11, {"0", "*1", "2"}},
            {13, {"0", "*1"}},
            {9, {"1"}},
            {8, {}},
            {6, {"*0", "*1"}},
            {1, {"0", "2"}},
            {15, {"0", "2"}},
            {18, {}},
            {22, {"*0", "1"}}
        };
        std::vector<int> _reduce_symbol_count = {1, 4, 3, 1, 1, 1, 2, 1, 0, 2, 3, 3, 1, 2, 1, 3, 1, 1, 0, 1, 1, 1, 2, 1, 1, 3, 1};
        std::vector<int> _reduce_non_terminal_index = {5, 3, 8, 12, 10, 2, 0, 14, 0, 11, 2, 12, 14, 7, 13, 1, 15, 4, 6, 13, 9, 8, 6, 1, 13, 13, 4};
        std::set<int> _non_grammar_tuple_reduce_set = {0, 3, 4, 5, 7, 12, 16, 17, 19, 20, 21, 23, 26};
    };
}

#endif
