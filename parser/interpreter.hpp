/*
    Boson v1.5 - Grammar analyzer generator

        Author: ict
        Email:  ictxiangxin@hotmail.com
        Site:   https://github.com/ictxiangxin/boson

    File: "interpreter.hpp"
    These codes ware generated by the boson C++ code generator.
*/

#ifndef _BOSON_INTERPRETER_HPP_
#define _BOSON_INTERPRETER_HPP_

#include <functional>
#include <vector>
#include <set>
#include <unordered_map>
#include "semantic_node.hpp"
#include "grammar_node.hpp"

namespace boson {
    template <class T>
    class Interpreter {
    public:
        using semantic_function = std::function<BosonSemanticsNode<T>(BosonSemanticsNode<T> &)>;

        Interpreter() = default;

        BosonSemanticsNode<T> execute(BosonGrammarNode &grammar_tree) {
            return this->_semantics_analysis(grammar_tree);
        }

        void register_action(const char *reduce_name, semantic_function function) {
            std::string reduce_name_string(reduce_name);
            this->register_action(reduce_name_string, function);
        }

        void register_action(std::string &reduce_name, semantic_function function) {
            this->_semantic_action_mapping[reduce_name] = function;
        }

    private:
        std::unordered_map<int, std::string> _reduce_number_grammar_name_mapping = {
            {11, "set_variable"}, 
            {18, "function"}, 
            {7, "compute"}, 
            {5, "compute"}, 
            {22, "compute"}, 
            {19, "expression"}, 
            {16, "get_variable"}, 
            {13, "number"}
        };
        std::set<int> _naive_reduce_number_set = {1, 2, 3, 6, 8, 12, 13, 16, 21, 23, 25};
        std::unordered_map<std::string, semantic_function> _semantic_action_mapping{};

        BosonSemanticsNode<T> _semantics_analysis(BosonGrammarNode &grammar_tree) {
            std::string grammar_name{};
            if (this->_reduce_number_grammar_name_mapping.count(grammar_tree.get_reduce_number())) {
                grammar_name = this->_reduce_number_grammar_name_mapping[grammar_tree.get_reduce_number()];
            } else {
                grammar_name = "!grammar_hidden";
            }
            BosonSemanticsNode<T> semantics_node;
            for (auto &node: grammar_tree.children()) {
                if (!node.children().empty()) {
                    semantics_node.append(this->_semantics_analysis(node));
                } else {
                    BosonSemanticsNode<T> temp_node;
                    temp_node.set_reduce_number(node.get_reduce_number());
                    temp_node.set_text(node.get_text());
                    semantics_node.append(temp_node);
                }
            }
            if (this->_semantic_action_mapping.count(grammar_name)) {
                return this->_semantic_action_mapping[grammar_name](semantics_node);
            } else if (this->_naive_reduce_number_set.count(grammar_tree.get_reduce_number())) {
                if (semantics_node.children().size() == 1) {
                    return semantics_node[0];
                } else {
                    return semantics_node;
                }
            } else {
                return semantics_node;
            }
        }
    };
}

#endif
